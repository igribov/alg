------------
Алгоритмы сортировки
------------

#### Сортировка пузырьком

Идея метода: шаг сортировки состоит в проходе снизу вверх по массиву. 
По пути просматриваются пары соседних элементов. 
Если элементы некоторой пары находятся в неправильном порядке, то меняем их местами.
Элемент с меньшим значением переставляется вперед.

После первого прохода в самом конце массива оказываемся наименьший элемент, далее мы проходим
по массиву не доходя до этого элемента.

```python

def bubbleSort(alist):
    for passnum in range(len(alist)-1,0,-1):
        for i in range(passnum):
            if alist[i]>alist[i+1]:
                temp = alist[i]
                alist[i] = alist[i+1]
                alist[i+1] = temp

```
Сортировка пузырьком имеет время работы *O*(`n`^2)

#### Сортировка выбором

Сортировка выбором осуществляется по следующему алгоритму :

1. Увеличивая счетчик 0 до `n`=*<длина массива>* получаем подмассив.
2. Например `i` = 1
3. В этом подмассиве ищем элемент с наименьшим значением
4. Меняем его с первым элементом подмассива местами.
5. Увеличиваем `i` на 1

```python
def selectionSort(A, n):
    for i in range(0, n):
        smallest = i
        for j in range(i+1, n):
            if A[j] < A[smallest]: smallest = j
        c = A[i]
        A[i] = A[smallest]
        A[smallest] = c
    return A
```

Сортировка выбоором имеет время работы *O*(`n`^2)

#### Сортировка вставкой

Сортировка выбором осуществляется по следующему алгоритму :

41 16 2 34 6 9 1 = исходный список

0. Мы берем первый элемент массива ипереносим его в отсортированную группу.
Понимаем, что по сути мы сним ничего с ним не делаем, просто начинается алгоритм с i = 1, а не с i=0
41 | 16 2 34 6 9 1

1. Для `i` от 1 до `len(A)` выполняем следующеее :
2. Берем `A[i]` = `A[1]` = `16` , и сравниваем его с отсортированными элементами (в той группе на момент начала цикла есть только 1 элемент)
      
3. 41 `16`|2 34 6 9 1  , видно, что `16` < `41`
4. 16 41 |2 34 6 9 1  
5. Продолжаем так для всех `i`
6. Получаем отсортированный массив на выходе.
```
def insertationSort(A, n):
    for i in range(1, n):
        key = A[i] # вытаскиваем текущее значение
        j = i - 1 # предыдущая позиция
        while j >= 0 :# передвигаем пока предыдущее больше
            
            if A[j] > key:
                A[j+1] = A[j]
                A[j] = key
            j-=1
```


#### Сортировка слиянием

Сортировка слиянием работает с привлечением дополнительной памяти.
Основные этапы : 

1. mergeSort разделяет список пополам
2. Каждую половину отправляет рекурсивно в mergeSort
3. Базовый случай рекурсии - длина подмассива <= 1
4. Таким образом происходит разделение данных, до минимального размера
5. В процедуру merge поступают список и индексы, которые делят его пополам, на два списка. Каждый из которых упорядочен.
Так происхолит, что в простейшем случае это два списка длины 1.
6. Эти списки дополняются последним элементом inf == +~ (бесконечность)
7. Процедура делает merge их между собой. Сравнивая их поэлементно и берет меньший на каждой итерации.

```
r - длина списка
def merge(A, p, q, r):
    
    B = A[p:q] + [INF]
    C = A[q:r] + [INF]
    
    i = j = 0
    for k in range(p, r):
        if B[i] <= C[j] :            
            A[k] = B[i]
            i+=1
        else:
            A[k] = C[j]
            j+=1

def mergeSort(A, p, r):
    if len(A[p:r]) <= 1:
        return A
    if p < r :
        q = ceil((p + r) / 2)
        mergeSort(A, p, q)
        mergeSort(A, q, r)
        merge(A, p, q, r)
    else:
        return
```
И еще похожая реализация : 
```
def merge(left, right):
    result = []
    i , j = 0 , 0
    while i < len (left) and j < len (right): # iterate through both arrays and arrange the elements in sorted order
        if left[i] <= right [j]:
            result.append(left[i])
            i+=1
        else:
            result.append(right[j])
            j+=1

    #The loop may break before all elements
    # are copied hence append the remaining elements
    result += left[i:]
    result += right[j:]
    return result


#The mergesort method to split the arrays into smaller subarrays
def mergesort(lst):
    if len(lst) <= 1:
        return lst
    middle = int(len(lst) / 2)
    left = mergesort(lst[:middle])
    right = mergesort(lst[middle:])
    return merge(left, right)
```

#### Быстрая сортировка
